#! /usr/bin/env bash


# manuel-contrib-watch
# act on changes to files


# Usage: manuel_watch [directory] [actions]
# where actions is an associative array.
#
# Example:
#
# function do_something {
#   declare -A actions=(
#     ["\.js$"]="echo 'we should concat and minify the js again'"
#     ["\.go$"]="go build ."
#   )
#
#   manuel_watch . actions
# }

function _get_md5_command {
  if [[ ! -z $(command -v md5) ]]; then
    echo $(which md5)
  elif [[ ! -z $(command -v md5sum) ]]; then
    echo $(which md5sum)
  else
    echo -e ">> Error: neither md5 nor md5sum found on PATH" 1>&2
    exit 1
  fi
}

function _hash_find {
  regex_pattern=$1
  result=$(find $target_dir -regex "$k" -printf '%Tc %p\n' | $md5_command)
  echo "$result"
}

function manuel_watch {
  target_dir=`readlink -f $1` # a directory to watch for changes in
  actions=$2          # associative array of regex=>command
  md5_command=$(_get_md5_command)

  # keep an associative array of hashes of results
  declare -A last_results

  # get initial hashes
  for k in ${!actions[@]}
  do
    if [[ "$k" == 0 ]]; then
      continue
    fi
    h=$(_hash_find "$k")
    last_results["$k"]=$h
  done

  echo -e ">> Watching $target_directory"

  while true; do

    for k in ${!actions[@]}
    do
      if [[ "$k" == "0" ]]; then
        continue
      fi

      # hash result
      h=$(_hash_find "$k")

      # check against previous hash
      if [[ ${last_results["$k"]} != $h ]]; then
        last_results["$k"]=$h
        echo "CHANGE"
        eval ${actions[$k]}
      fi
    done

    sleep 1

  done
}
